///////////////////////////////////////////////////////////////////////////////
/// @file   Main.cpp
/// @author Jacob Adkins (jpadkins)
/// @brief  Entry point of the application
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// Headers
///////////////////////////////////////////////////////////////////////////////
#include <list>
#include <memory>

#include "Game.hpp"
#include "Common.hpp"
#include "GlyphTileMap.hpp"

///////////////////////////////////////////////////////////////////////////////
/// Forward declarations for State
///////////////////////////////////////////////////////////////////////////////
class FrameManager;

///////////////////////////////////////////////////////////////////////////////
/// @brief Singleton holding references to different management classes
///////////////////////////////////////////////////////////////////////////////
class State {
public:

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Disable copy constructor
    ///////////////////////////////////////////////////////////////////////////
    State(const State&) = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Disable assignment operator
    ///////////////////////////////////////////////////////////////////////////
    void operator=(const State&) = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Returns a reference to the global State instance
    ///
    /// @return A reference to the global State instance
    ///////////////////////////////////////////////////////////////////////////
    static State& get();

private:

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Default constructor
    ///////////////////////////////////////////////////////////////////////////
    State() = default;

    ///////////////////////////////////////////////////////////////////////////
    std::unique_ptr<FrameManager> m_frameManager;
};

///////////////////////////////////////////////////////////////////////////////
State& State::get()
{
    static State state;
    return state;
}

///////////////////////////////////////////////////////////////////////////////
//// @brief Shorter equivalent to a common multiple inheritance
///////////////////////////////////////////////////////////////////////////////
class DrawAndTransform : public sf::Drawable, public sf::Transformable {};

///////////////////////////////////////////////////////////////////////////////
/// @brief Abstract class for anything that is updated each frame
///////////////////////////////////////////////////////////////////////////////
class Updatable {
public:

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Default constructor
    ///////////////////////////////////////////////////////////////////////////
    Updatable() = default;

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Default copy constructor
    ///////////////////////////////////////////////////////////////////////////
    virtual ~Updatable() = default;

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Signature of virtual update function
    ///////////////////////////////////////////////////////////////////////////
    virtual void update(sf::Uint32 deltaMs) = 0;
};

///////////////////////////////////////////////////////////////////////////////
/// @brief Abstract class for all GUI elements
///////////////////////////////////////////////////////////////////////////////
class Frame : public Updatable, public DrawAndTransform {};

///////////////////////////////////////////////////////////////////////////////
/// @brief Manages the rendering of all active Frames
///////////////////////////////////////////////////////////////////////////////
class FrameManager : public sf::Drawable {
public:

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Default constructor
    ///////////////////////////////////////////////////////////////////////////
    FrameManager() = default;

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Removes an open Frame
    ///
    /// @param tag  Tag of the Frame to remove
    ///////////////////////////////////////////////////////////////////////////
    void remove(const std::string& tag);

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Moves a Frame with a matching tag to the highest z-level
    ///
    /// @param tag  Tag of the Frame to move to ontop of all the others
    ///////////////////////////////////////////////////////////////////////////
    void setHighest(const std::string& tag);

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Adds a new Frame to be managed
    ///
    /// @param tag      Tag of the Frame to manage
    /// @param frame    Pointer to the Frame to be managed
    ///////////////////////////////////////////////////////////////////////////
    void add(const std::string& tag, Frame* frame);

private:
    ///////////////////////////////////////////////////////////////////////////
    /// @brief Typedefs
    ///////////////////////////////////////////////////////////////////////////
    typedef std::pair<std::string, std::unique_ptr<Frame>> FrameHandle;

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Overloaded draw frunction from sf::Drawable/sf::Transformable
    ///////////////////////////////////////////////////////////////////////////
    void draw(sf::RenderTarget& target, sf::RenderStates) const override;

    ///////////////////////////////////////////////////////////////////////////
    /// @brief Returns an iterator to the first FrameHandle with a matching tag
    ///////////////////////////////////////////////////////////////////////////
    std::list<FrameHandle>::iterator getFrameIter(const std::string& tag);

    ///////////////////////////////////////////////////////////////////////////
    std::list<FrameHandle> m_frames;
};

///////////////////////////////////////////////////////////////////////////////
void FrameManager::remove(const std::string& tag)
{
    auto frameIter = getFrameIter(tag);
    if (frameIter != m_frames.end()) {
        m_frames.erase(frameIter);
    }
    else {
        log_warn("Frame is not open: " + tag);
    }
}

///////////////////////////////////////////////////////////////////////////////
void FrameManager::setHighest(const std::string& tag)
{
    auto frameIter = getFrameIter(tag);
    if (frameIter != m_frames.end()) {
        m_frames.splice(m_frames.end(), m_frames, frameIter);
    }
    else {
        log_warn("Frame is not open: " + tag);
    }
}

///////////////////////////////////////////////////////////////////////////////
void FrameManager::add(const std::string& tag, Frame* frame)
{
    m_frames.emplace_back(std::make_pair(tag, std::make_unique<Frame>(frame)));
}

///////////////////////////////////////////////////////////////////////////////
void FrameManager::draw(sf::RenderTarget& target, sf::RenderStates) const
{
    for (auto& frame : m_frames) { target.draw(*frame.second); }
}

///////////////////////////////////////////////////////////////////////////////
std::list<FrameManager::FrameHandle>::iterator FrameManager::getFrameIter(
    const std::string& tag)
{
    auto tagsEqual = [tag](const FrameHandle& handle) {
        return handle.first == tag;
    };

    return std::find_if(m_frames.begin(), m_frames.end(), tagsEqual);
}

///////////////////////////////////////////////////////////////////////////////
/// Main
///////////////////////////////////////////////////////////////////////////////
int main()
{
    auto windowMode = sf::VideoMode::getFullscreenModes()[0];
    Game::Settings gameSettings = {
        {
            true,
            sf::Style::Fullscreen,
            "SFML App",
            windowMode,
            60
        },
        {
            {256, 224}
        }
    };

    Game game(gameSettings);
    game.play();

    return 0;
}
